<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ferjm</title>
    <description>coding out loud</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 19 Jun 2019 13:32:27 +0200</pubDate>
    <lastBuildDate>Wed, 19 Jun 2019 13:32:27 +0200</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Project Link Networking</title>
        <description>&lt;p&gt;For the last few months, I have been involved in &lt;a href=&quot;https://wiki.mozilla.org/Project_Link&quot;&gt;Project Link&lt;/a&gt;, one of Mozilla’s &lt;a href=&quot;https://wiki.mozilla.org/Connected_Devices&quot;&gt;Connected Devices&lt;/a&gt; new research projects that aims to create a personal User Agent for the smart homes.&lt;/p&gt;

&lt;p&gt;We have recently completed our &lt;a href=&quot;https://wiki.mozilla.org/Project_Link#Phase_1&quot;&gt;first milestone&lt;/a&gt; where we managed to prototype a device that is able to communicate with a small set of other different devices through some wireless communication protocols like &lt;a href=&quot;https://en.wikipedia.org/wiki/ZigBee&quot;&gt;Zigbee&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Z-Wave&quot;&gt;Z-Wave&lt;/a&gt; and that exposes an &lt;a href=&quot;https://wiki.mozilla.org/Connected_Devices/Projects/Project_Link/Taxonomy#Current_REST_API&quot;&gt;HTTP API&lt;/a&gt; for clients to get moderated access to these devices through the Link hub. So as today, we are able to setup a Link device in a network where other devices like a set of smart light bulbs, a smart door lock and a motion sensor are connected and we are able to create rules, from inside and outside of that network, to do things like turning off the lights, locking the door and sending a notification when the motion sensor detects that the user leaves her home.&lt;/p&gt;

&lt;p&gt;Making Link communicate with the different devices through Zigbee or Z-Wave was certainly not an easy task and it required a lot of effort from many members of the team. But it was something that somehow we knew that we could do. In the end, these are known protocols, and even if we had to write a lot of code from scratch because of the choice of technology (&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt;), there are already a lot of products in the market based on these technologies and a few examples of code that we could take as a starting point for our work.&lt;/p&gt;

&lt;p&gt;To me, one of the most interesting challenges that we had to face during this initial stage of the project has been how to discover and securely connect to Link (a.k.a &lt;em&gt;the box&lt;/em&gt;) from the client side while keeping a decent UX.&lt;/p&gt;

&lt;p&gt;As Mozillians, &lt;a href=&quot;https://www.youtube.com/watch?v=Aw4mTrFW9sU&quot;&gt;we believe in the power of the web&lt;/a&gt;, so one of our self-imposed initial requirements for this project was that we wanted our &lt;a href=&quot;https://github.com/fxbox/app&quot;&gt;client demo application&lt;/a&gt; to be written entirely with web technologies. We wanted to make this client potentially able to run on any platform with a modern web browser. And there were also other requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;This client had to be able to access Link locally, from the same network where the Link device was running on, but also remotely, from outside of that network.&lt;/li&gt;
  &lt;li&gt;The connection between Link and the client had to be securely encrypted in both cases (local and remote access).&lt;/li&gt;
  &lt;li&gt;And both things needed to happen seamlessly and transparently for the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://michielbdejong.com/&quot;&gt;Michiel B. de Jong&lt;/a&gt; did an excellent research work about the discovery and secure connection area and he proposed a few &lt;a href=&quot;https://github.com/fxbox/RFC/issues/3&quot;&gt;different solutions&lt;/a&gt; to these problems, that included different combinations of cloud, &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_code&quot;&gt;QR codes&lt;/a&gt;, &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Multicast_DNS&quot;&gt;mDNS&lt;/a&gt; and other technologies and protocols.&lt;/p&gt;

&lt;p&gt;While we do not discard implementing any other of these proposals for the next phases of the project, for the initial prototype we ended up choosing a solution that most part of the team considered that had a good balance between security, privacy and user friendly experience and that could work cross platform and cross browser, taking advantage of the full power of the web.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Discovering the box&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the discovery part, we implemented the same mechanism that Philips uses to discover their &lt;a href=&quot;http://www.developers.meethue.com/documentation/getting-started&quot;&gt;Hue Lights Bridge&lt;/a&gt;. They call this &lt;em&gt;nUPNP&lt;/em&gt; (network UPNP). And it is pretty simple. It requires Link to periodically register itself with a server in the cloud that has a known URL for the client. The data that is stored for this registration is a match between Link’s public and local IP addresses. To get the local address, the client just needs to do a HTTP GET request to the registration server &lt;em&gt;ping&lt;/em&gt; endpoint, which should return a JSON object containing this information. This request has to be done from the same network Link is connected to.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Securely connecting to the box&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, we cannot securely connect to local IP addresses through HTTPS. At least not with a proper UX that would not require a terrified user to accept warnings about &lt;a href=&quot;https://support.cdn.mozilla.net/media/uploads/gallery/images/2011-10-19-09-09-25-5809bb.jpg&quot;&gt;insecure connections&lt;/a&gt;, and even in that case (with a self-signed certificate), it would be quite a poor security solution. We needed host names and a trusted &lt;a href=&quot;https://en.wikipedia.org/wiki/Certificate_authority&quot;&gt;CA&lt;/a&gt; for this. And here is where Let’sEncrypt and &lt;a href=&quot;https://blog.filippo.io/how-plex-is-doing-https-for-all-its-users/&quot;&gt;Plex’s solution&lt;/a&gt; enter in the game.&lt;/p&gt;

&lt;p&gt;We heard about this company called Plex that has a very similar use case as ours and that is offering secure TLS connections to all their users. They have these media servers that users can self-host in their machines and can access to them securely from other devices. You can read about the details of Plex’s implementation in this &lt;a href=&quot;https://blog.filippo.io/how-plex-is-doing-https-for-all-its-users/&quot;&gt;blog post&lt;/a&gt; and see how it slightly defers from ours.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remotely accessing the box (a.k.a tunneling)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To provide remote access to Link for those users that choose to have this kind of feature, we initially tried to use &lt;a href=&quot;https://ngrok.com/&quot;&gt;ngrok&lt;/a&gt;, but we found out that they do not support &lt;a href=&quot;https://es.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; on their open source version. So we ended up moving to &lt;a href=&quot;https://pagekite.net/&quot;&gt;PageKite&lt;/a&gt;, which offers the same core functionality but also provides SNI support.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Putting it all together&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With all the above we ended up implementing the following bootstrap process for Link:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Link exposes HTTP and WebSockets services.&lt;/li&gt;
  &lt;li&gt;First thing that Link does is to generate a self-signed certificate that becomes its identifier.&lt;/li&gt;
  &lt;li&gt;It connects to an &lt;a href=&quot;https://github.com/fxbox/dns-server&quot;&gt;API&lt;/a&gt; on &lt;code class=&quot;highlighter-rouge&quot;&gt;knilxof.org&lt;/code&gt; (our dev server) to create its public DNS zone under &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;fingerprint&amp;gt;.knilxof.org&lt;/code&gt;, using its self-signed certificate as a client certificate. The API server checks the fingerprint from the DNS zone edit request against the fingerprint of the client certificate presented.&lt;/li&gt;
  &lt;li&gt;Now that the Box has a public DNS zone it can control, it can get a LetsEncrypt certificate, using the &lt;a href=&quot;https://letsencrypt.github.io/acme-spec/#rfc.section.7.4&quot;&gt;DNS-01 challenge&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Link sets its main DNS A record to its current &lt;strong&gt;local&lt;/strong&gt; IP address which it obtained via DHCP earlier. It will update this A record whenever its local IP address changes.&lt;/li&gt;
  &lt;li&gt;It also sets two or more mirror A records to its current local IP address. The idea here being that only one of the records will be cached by caching DNS servers, so switching to the other one at the right time will avoid downtime due to DNS propagation delays. This is currently not implemented.&lt;/li&gt;
  &lt;li&gt;If Link is setup to allow remote access, it starts up a PageKite client, which connects to a PageKite frontend, and adds the IP address of the public interface to the PageKite frontend into its DNS zone.&lt;/li&gt;
  &lt;li&gt;With the local, mirrors and tunneled URLs, Link sends a registration request to the nUPNP like &lt;a href=&quot;https://github.com/fxbox/registration_server&quot;&gt;registration server&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After the above process is completed, when the user browses to our &lt;a href=&quot;https://github.com/fxbox/app&quot;&gt;client demo application&lt;/a&gt;, the app makes a cross-origin request to the registration server &lt;em&gt;ping&lt;/em&gt; endpoint to obtain the URLs the app can use to securely connect to Link.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /ping HTTP/1.1

HTTP/1.1 200 OK  
Access-Control-Allow-Origin: *  
Access-Control-Allow-Headers: accept, authorization, content-type  
Content-Type: application/json; charset=utf-8  
Access-Control-Allow-Methods: GET, POST, PUT  
Content-Length: 312  
Date: Fri, 22 Apr 2016 14:39:44 GMT

[{&quot;public_ip&quot;:&quot;88.xxx.xxx.xxx&quot;,&quot;client&quot;:&quot;80a3c3ff0ffc7da455214fe7daaed9216bc4a5a6&quot;,&quot;message&quot;:&quot;{\&quot;local_origin\&quot;:\&quot;https://local.80a3c3ff0ffc7da455214fe7daaed9216bc4a5a6.box.knilxof.org:3000\&quot;,\&quot;tunnel_origin\&quot;:\&quot;https://remote.80a3c3ff0ffc7da455214fe7daaed9216bc4a5a6.box.knilxof.org\&quot;}&quot;,&quot;timestamp&quot;:1461335726}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The connection to the box is completely seamless for the user as she is never asked to enter a URL or to add any security exception on her browser.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2016/04/Screen-Shot-2016-04-22-at-5-09-24-PM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Credits&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Most part of the design and implementation work has been done by &lt;a href=&quot;http://michielbdejong.com/&quot;&gt;Michiel B. de Jong&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/samuelgiles_&quot;&gt;Sam Giles&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Apr 2016 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/mozilla/iot/networking/2016/04/22/project-link-networking.html</link>
        <guid isPermaLink="true">http://localhost:4000/mozilla/iot/networking/2016/04/22/project-link-networking.html</guid>
        
        
        <category>mozilla</category>
        
        <category>iot</category>
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>Improving the Firefox OS Contacts application start-up time</title>
        <description>&lt;p&gt;One of the biggest challenges that we have in Firefox OS is the &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Build/Performance/Performance_fundamentals&quot;&gt;performance&lt;/a&gt;. We have been fighting it since day one and by applying some &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Build/Performance/Optimizing_startup_performance&quot;&gt;different techniques&lt;/a&gt; we managed to get to a point where we have some very decent &lt;a href=&quot;https://datazilla.mozilla.org/b2g&quot;&gt;application start-up time numbers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The last application to get a considerable performance boost has been the Contacts application.&lt;/p&gt;

&lt;p&gt;During the last few weeks, the Contacts team &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1112551&quot;&gt;has been working&lt;/a&gt; on a &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/commit/f1d0684817e5802961c02a04dcf667cfaf09d6ee&quot;&gt;patch&lt;/a&gt; that finally landed on master yesterday. The result is an improvement of around 720 milliseconds of &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Build/Performance/Firefox_OS_app_responsiveness_guidelines#Stages&quot;&gt;perceived start-up time&lt;/a&gt;, which means that we saved almost 50% of the previous start-up time.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://datazilla.mozilla.org/b2g/?branch=master&amp;amp;device=flame-319MB&amp;amp;range=7&amp;amp;test=startup_%3E_moz-app-visually-complete&amp;amp;app_list=communications/contacts&amp;amp;app=communications/contacts&amp;amp;gaia_rev=9645d45d5777880e&amp;amp;gecko_rev=f6259882882b&amp;amp;plot=median&quot;&gt;Datazilla&lt;/a&gt; already shows the change.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2015/03/contactsperfimprovement-1.png&quot; alt=&quot;Datazilla changes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/stasm/test-perf-summary&quot;&gt;Comparing&lt;/a&gt; the results of running the &lt;a href=&quot;https://developer.mozilla.org/en-US/Firefox_OS/Platform/Automated_testing/Gaia_performance_tests&quot;&gt;Gaia performance tests&lt;/a&gt; with a heavy workload before and after the patch we get the following numbers:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;communications/contacts (means in ms)&lt;/th&gt;
      &lt;th&gt;Base&lt;/th&gt;
      &lt;th&gt;Patch&lt;/th&gt;
      &lt;th&gt;Δ&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moz-chrome-dom-loaded&lt;/td&gt;
      &lt;td&gt;1147&lt;/td&gt;
      &lt;td&gt;585&lt;/td&gt;
      &lt;td&gt;-562&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moz-chrome-interactive&lt;/td&gt;
      &lt;td&gt;1267&lt;/td&gt;
      &lt;td&gt;1393&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moz-app-visually-complete&lt;/td&gt;
      &lt;td&gt;1601&lt;/td&gt;
      &lt;td&gt;874&lt;/td&gt;
      &lt;td&gt;-727&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moz-content-interactive&lt;/td&gt;
      &lt;td&gt;2131&lt;/td&gt;
      &lt;td&gt;1393&lt;/td&gt;
      &lt;td&gt;-738&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moz-app-loaded&lt;/td&gt;
      &lt;td&gt;10942&lt;/td&gt;
      &lt;td&gt;10409&lt;/td&gt;
      &lt;td&gt;-533&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see we are sending the &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-app-visually-complete&lt;/code&gt; event ~727 milliseconds earlier than before. This is the event that we use to indicate that the application appears visually ready for user interaction and the one that we really want to send as soon as possible. We also get similar improvements for the &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-chrome-dom-loaded&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-content-interactive&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-app-loaded&lt;/code&gt; events. You can also notice that we had to make some trade offs and we lost some ground with the &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-chrome-interactive&lt;/code&gt; event. If you look closer, you will see that chrome and content are marked as interactive at the same time. This was not happening before. We were not able to interact with the application content until almost one second after being able to interact with the application chrome. Now we have everything ready at once ~700 milliseconds before and given that the most important part of the Contacts application is the contacts data itself, we consider that the small lost in the &lt;code class=&quot;highlighter-rouge&quot;&gt;moz-chrome-interactive&lt;/code&gt; event is worth the result. You can check the &lt;a href=&quot;https://developer.mozilla.org/en-US/Apps/Build/Performance/Firefox_OS_app_responsiveness_guidelines#Stages&quot;&gt;MDN responsiveness guidelines&lt;/a&gt; page for more details about these events.&lt;/p&gt;

&lt;p&gt;I recorded a quick video comparing the previous situation (left) with the current one (right). (Apologies for the low quality of the recording).&lt;/p&gt;

&lt;iframe title=&quot;vimeo-player&quot; src=&quot;https://player.vimeo.com/video/121901924&quot; width=&quot;710&quot; height=&quot;360&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;how-did-we-get-there&quot;&gt;How did we get there&lt;/h2&gt;

&lt;p&gt;The target was to have some usable UI ready as soon as possible before the browser painted anything on the screen. For us, this usable UI is the application chrome with the &lt;code class=&quot;highlighter-rouge&quot;&gt;Add contact&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Settings&lt;/code&gt; options and the first chunk of contacts, including favorite and &lt;a href=&quot;http://en.wikipedia.org/wiki/In_case_of_emergency&quot;&gt;ICE&lt;/a&gt; contacts.&lt;/p&gt;

&lt;p&gt;So far we were not doing bad showing the application chrome, but we were taking extra time to load the first group of visible contacts. To show this first content we needed to do a request to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mozContacts&quot;&gt;MozContacts API&lt;/a&gt; to obtain the list of stored contacts and start appending to the DOM one new node per each contact information retrieved. The thing is that the result of this request rarely changed from one execution to the other. So why not caching it?&lt;/p&gt;

&lt;p&gt;We followed the same approach that the Email team already applied on the &lt;a href=&quot;https://groups.google.com/forum/#!topic/mozilla.dev.gaia/v_jVuwOJMKI&quot;&gt;Email application&lt;/a&gt; for caching the email list. We used &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;localStorage&lt;/a&gt; to save the result of getting the contacts list from the MozContacts API and rendering the first chunk of contacts. To avoid having to do object serialization and parsing before and after accessing the localStorage item, we initially tried storing the whole &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/outerHTML&quot;&gt;outerHTML&lt;/a&gt; string of the &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/contacts/index.html#L218&quot;&gt;contacts groups container&lt;/a&gt; holding the first chunk of contacts and applying it via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML&lt;/a&gt;, but that did not give good enough performance and it made the logic for managing the contacts cache harder. Also, in the end we figured out that we needed to store other information like the language direction or the cache date along with the HTML to decide wether the cache was valid or not, so object serialization and parsing was required in any case. Instead of that, we ended up storing an object with this information to ease the cache eviction decision and enough information to rebuild the DOM containing the first chunk of contacts. We applied this data to the DOM via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment&quot;&gt;documentFragment&lt;/a&gt;. You can checkout the code for &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/contacts/js/views/list.js#L2274&quot;&gt;building&lt;/a&gt; and &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/contacts/js/bootstrap.js#L173&quot;&gt;applying&lt;/a&gt; the cache.&lt;/p&gt;

&lt;p&gt;The trickiest part of maintaining this cache is the eviction policy. We need to evict and rebuild the cache every time a contact is changed (added, removed or edited) and because this can happen from inside and from outside of the Contacts app (even when the app is closed), we need to be specially careful and verify the cache after applying it to the DOM without affecting the performance or causing visual reflows. You can follow &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/contacts/js/views/list.js#L2375&quot;&gt;this code&lt;/a&gt; to see how we managed to do that. Other scenarios where we need to evict the cache are language direction changes, &lt;a href=&quot;http://en.wikipedia.org/wiki/In_case_of_emergency&quot;&gt;ICE&lt;/a&gt; contacts changes, favorite contacts modifications and when the user changes the way the contacts are displayed (by first or last name).&lt;/p&gt;

&lt;p&gt;Apart from building the cache mechanism we also changed the application bootstrap process in a way that we only load the minimum set of scripts required to get the cached information from localStorage and to apply it in the DOM. Once we have this process completed, we load the rest of the application Javascript that is required to continue the rest of the boot process. You can see this logic in the new &lt;a href=&quot;https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/contacts/js/bootstrap.js#L410&quot;&gt;bootstrap&lt;/a&gt; script.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;We want to keep improving the performance of the Contacts application. The next thing that we want to target is improving the loading of the contacts thumbnails. In fact, &lt;a href=&quot;https://twitter.com/mepartoconmigo&quot;&gt;Francisco Jordano&lt;/a&gt; has already started working on &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1089538&quot;&gt;it&lt;/a&gt; and there are already some visible improvements.&lt;/p&gt;

&lt;iframe width=&quot;710&quot; height=&quot;381&quot; src=&quot;https://www.youtube-nocookie.com/embed/lOx-Ym2qUlM&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;We also want to experiment with caching most part or even the whole contacts list in different chunks to allow the user to use the alpha scrolling and to get a fully loaded application even sooner.&lt;/p&gt;

&lt;p&gt;Finally, the Gaia team is starting to play around with &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/service-worker/introduction/&quot;&gt;Service Workers&lt;/a&gt; and with the idea of using this new feature to cache already rendered views in a similar way that we did for Contacts. I cannot wait to see more progress in this area :)&lt;/p&gt;

&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/mepartoconmigo&quot;&gt;Francisco Jordano&lt;/a&gt;, &lt;a href=&quot;https://github.com/JohanLorenzo&quot;&gt;Johan Lorenzo&lt;/a&gt;, &lt;a href=&quot;http://sergimansilla.com/&quot;&gt;Sergi Mansilla&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Mar 2015 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/firefoxos/performance/2015/03/11/improving-fxos-contacts-application-start-up-time.html</link>
        <guid isPermaLink="true">http://localhost:4000/firefoxos/performance/2015/03/11/improving-fxos-contacts-application-start-up-time.html</guid>
        
        
        <category>firefoxos</category>
        
        <category>performance</category>
        
      </item>
    
  </channel>
</rss>
